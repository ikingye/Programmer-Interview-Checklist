'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/interview-me/docs/os/','title':"操作系统",'content':"操作系统 "});index.add({'id':1,'href':'/interview-me/docs/network/','title':"网络",'content':"网络 "});index.add({'id':2,'href':'/interview-me/docs/algs/','title':"算法",'content':"算法 "});index.add({'id':3,'href':'/interview-me/docs/pl/','title':"编程语言",'content':"编程语言 "});index.add({'id':4,'href':'/interview-me/docs/os/linux/','title':"Linux",'content':"Linux "});index.add({'id':5,'href':'/interview-me/docs/network/http/','title':"HTTP",'content':"HTTP HTTP 基础 HTTP 状态码有哪些？  2XX 成功  200 ok（请求成功） 204 no content （请求成功，但是没有结果返回） 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）   3XX 重定向  301 move permanently （永久性重定向） 302 found （临时性重定向） 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源） 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关） 307 temporary redirect （跟 302 一个意思）   4XX 客户端错误  400 bad request （请求报文存在语法错误） 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回）） 403 forbidden （请求被服务器拒绝了） 404 not found （服务器上无法找到请求的资源）   5XX 服务器错误  500 internal server error （服务端执行请求时发生了错误） 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）    301 和 302 有什么区别？分别适用于什么场景？ 101， 304， 307 分别是什么？ 101 协议升级\n主要用于 websocket，也可以用于 http2 的升级。\n304 协商缓存\n浏览器缓存分为强制缓存和协商缓存，优先读取强制缓存。\n强制缓存分为 expires 和 cache-control，而 expires 是一个特定的时间，是比较旧的标准和 cache-control 通常是一个具体的时间长度，比较新，优先级也比较高。\n307 hsts 跳转\n原本的用法是用于让 post 请求的跳转去新的 post 请求，但也用于 hsts 跳转。\nhsts 全称 HTTP 严格传输安全（HTTP Strict Transport Security，縮寫：HSTS），功能是要求浏览器下次访问该站点时使用 https 来访问，而不再需要先是 http 再转 https。这样可以避免 ssl 剥离攻击，即攻击者在用户使用 http 访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用 https 访问，在用户和服务器中使用 http 访问。\n具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age\n参考：\n 面试必考之 http 状态码有哪些   HTTP chunk 是什么？解决了什么问题？  HTTP/1.1 有哪些问题？  TCP 连接数限制   问题：对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接 (不同浏览器不一样) 解决：域名分片 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)  还有问题：每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存    队头阻塞（ Head-of-line blocking 或缩写为 HOL blocking ）   问题：每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。 解决： HTTP 管线化  还有问题：比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化    Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案 为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制 明文传输不安全  参考：\n HTTP2 详解    HTTP2 HTTP2 有哪些特点？  二进制分帧层 (Binary Framing Layer)  帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧   多路复用 (MultiPlexing) 服务端推送 (Server Push) Header 压缩 (HPACK) 应用层的重置连接 请求优先级设置 流量控制 HTTP/1 的几种优化可以弃用  合并文件、内联资源、雪碧图、域名分片对于 HTTP/2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多    参考：\n HTTP2 详解  HTTP2 多路复用是如何实现的？   HTTPS "});index.add({'id':6,'href':'/interview-me/docs/os/linux/info/','title':"Linux 系统信息",'content':"Linux 系统信息 硬件信息 如何查看内存大小？ free -m 如何查看 CPU 个数，CPU 核心数，逻辑 CPU 个数？ # 物理 cpu 个数 cat /proc/cpuinfo| grep \u0026#39;physical id\u0026#39; | sort | uniq | wc -l # 每个物理 cpu 的核心数 cat /proc/cpuinfo| grep \u0026#39;core id\u0026#39; | sort | uniq | wc -l # 逻辑 cpu 个数（线程数） cat /proc/cpuinfo| grep \u0026#39;processor\u0026#39; | sort | uniq | wc -l 例子：\n 2 个 cpu 每个 cpu 有 8 个核心（一共 16 个核心） 一共有 32 个逻辑 cpu / 线程（每个核心有 2 个逻辑 cpu / 线程）   如何查看系统内核？ uname -a cat /proc/version 如何查看操作系统版本？ cat /etc/issue cat /etc/*release  运行信息 如何查看占用内存最多的进程？ 如何查看占用 CPU 最多的进程？ 如何查看占用某个端口的进程？ "});index.add({'id':7,'href':'/interview-me/docs/os/linux/shell/','title':"Shell",'content':"Shell ps ps aux 与 ps -ef 有什么区别？  lsof awk sed "});index.add({'id':8,'href':'/interview-me/docs/network/tcp/','title':"TCP/UDP/IP",'content':"TCP/UDP/IP TCP "});index.add({'id':9,'href':'/interview-me/docs/security/web/','title':"Web 安全",'content':"Web 安全  一切的安全问题都体现在 “输入输出” 上，一切的安全问题都存在于 “数据流” 的整个过程中。\n 1. 如果在操作系统层上没处理好，比如 Linux 的 Bash 环境把 “特殊数据” 当做指令执行时，就产生了 OS 命令执行的安全问题，这段 “特殊数据” 可能长得如下这般： ; rm -rf /; 2. 如果在存储层的数据库中没处理好，数据库的 SQL 解析引擎把这个 “特殊数据” 当做指令执行时，就产生 SQL 注入这样的安全问题，这段 “特殊数据” 可能长得如下这般： ' union select user, pwd, 1, 2, 3, 4 from users-- 3. 如果在 Web 容器层如 nginx 中没处理好，nginx 把 “特殊数据” 当做指令执行时，可能会产生远程溢出、DoS 等各种安全问题，这段 “特殊数据” 可能长得如下这般： %c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./%20 4. 如果在 Web 开发框架或 Web 应用层中没处理好，把 “特殊数据” 当做指令执行时，可能会产生远程命令执行的安全问题，这段 “特殊数据” 可能长得如下这般： eval($_REQUEST['x']); 5. 如果在 Web 前端层中没处理好，浏览器的 JS 引擎把 “特殊数据” 当做指令执行时，可能会产生 XSS 跨站脚本的安全问题，这段 “特殊数据” 可能长得如下这般： '\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert(/cos is my hero./)\u0026lt;/script\u0026gt; ...  参考：\n 零基础如何学习 Web 安全？  "});index.add({'id':10,'href':'/interview-me/docs/security/web/xss/','title':"XSS",'content':"XSS Cross-site scripting 跨站脚本 (wiki)\nXSS 发生的原因 没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。 攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。\n不仅仅是业务上的 “用户的 UGC 内容” 可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：\n 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入）  XSS 有哪些注入的方法  在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(\u0026quot;javascript:...\u0026quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。   XSS 分类 存储型 存储型 XSS 的攻击步骤：\n 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n反射型 反射型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  反射型 XSS 跟存储型 XSS 的区别是：\n 存储型 XSS 的恶意代码存在数据库里， 反射型 XSS 的恶意代码存在 URL 里。  反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\nDOM 型 DOM 型 XSS 的攻击步骤：\n 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。  DOM 型 XSS 跟前两种 XSS 的区别：\n DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞， 其他两种 XSS 都属于服务端的安全漏洞。   防止 XSS 输入过滤 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。 在防范 XSS 攻击时应避免此类方法。\n当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。\n纯前端渲染 纯前端渲染，把代码和数据分隔开\n纯前端渲染的过程：\n 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。  在纯前端渲染中，我们会明确的告诉浏览器： 下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。 浏览器不会被轻易的被欺骗，执行预期外的代码了。\n但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等）。\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。 但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。\n对 HTML 做充分转义 对插入到页面中的数据进行转义， 通常是把 \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' / 这几个字符转义掉， 确实能起到一定的 XSS 防护作用，但要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。\nHTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。\n常用的模板引擎，如 doT.js、ejs、FreeMarker 等， Java 工程里，常用的转义库为 org.owasp.encoder。\n验证 href 的值 对于链接跳转，如 \u0026lt;a href=\u0026quot;xxx\u0026quot; 或 location.href=\u0026quot;xxx\u0026quot;，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。\n// 根据项目情况进行过滤，禁止掉 \u0026#34;javascript:\u0026#34; 链接、非法 scheme 等 allowSchemes = [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;]; valid = isValid(getParameter(\u0026#34;redirect_to\u0026#34;), allowSchemes); if (valid) { \u0026lt;a href=\u0026#34;\u0026lt;%= escapeHTML(getParameter(\u0026#34;redirect_to\u0026#34;))%\u0026gt;\u0026#34;\u0026gt; 跳转... \u0026lt;/a\u0026gt; } else { \u0026lt;a href=\u0026#34;/404\u0026#34;\u0026gt; 跳转... \u0026lt;/a\u0026gt; } 不区分大小写，可以带空格  JavaScript 不区分大小写： jAvascRipt:alert('XSS') 可以带空格 %20： %20javascript:alert('XSS')   escapeEmbedJSON 插入 JSON 的地方不能使用 escapeHTML()，因为转义 \u0026quot; 后，JSON 格式会被破坏。\n\u0026lt;script\u0026gt; var initData = \u0026lt;%= data.toJSON() %\u0026gt; \u0026lt;/script\u0026gt; 这样内联 JSON 也是不安全的\n 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 \u0026lt;/script\u0026gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 \u0026lt;script\u0026gt; 标签等方法就可以完成注入。  \u0026lt;script\u0026gt; // 实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义  var initData = \u0026lt;%= escapeEmbedJSON(data.toJSON()) %\u0026gt; \u0026lt;/script\u0026gt;  预防 DOM 型 XSS 攻击 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上， 而应尽量使用 .textContent、.setAttribute() 等。\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能， 就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， \u0026lt;a\u0026gt; 标签的 href 属性， JavaScript 的 eval()、setTimeout()、setInterval() 等， 都能把字符串作为代码运行。\n\u0026lt;!-- 内联事件监听器中包含恶意代码 --\u0026gt; ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,) \u0026lt;!-- 链接内包含恶意代码 --\u0026gt; \u0026lt;a href=\u0026#34;UNTRUSTED\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; // setTimeout()/setInterval() 中调用恶意代码  setTimeout(\u0026#34;UNTRUSTED\u0026#34;); setInterval(\u0026#34;UNTRUSTED\u0026#34;); // location 调用恶意代码  location.href = \u0026#34;UNTRUSTED\u0026#34;; // eval() 中调用恶意代码  eval(\u0026#34;UNTRUSTED\u0026#34;); \u0026lt;/script\u0026gt;  Content Security Policy 严格的 CSP 在 XSS 的防范中可以起到以下的作用：\n 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。  输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。 虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。\n其他安全措施  HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。   XSS 的检测 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert()//\u0026gt;\\x3e 只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。\n能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞， 也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞， 并且能绕过一些 XSS 过滤器。\n自动扫描工具  Arachni Mozilla HTTP Observatory w3af   参考  在学习 XSS 前应该学习什么？ 前端安全系列（一）：如何防止 XSS 攻击？  "});index.add({'id':11,'href':'/interview-me/docs/algs/tree/','title':"二叉树",'content':"二叉树 "});index.add({'id':12,'href':'/interview-me/docs/os/memory/','title':"内存",'content':"内存 综合 程序加载的时候，是怎么分布的，哪些在堆里，哪些在栈里？  堆  栈 "});index.add({'id':13,'href':'/interview-me/docs/other/encryption/','title':"加密",'content':"加密 SSL/TLS TLS 握手流程是什么样的？ 参考：\n SSL/TLS 详解  "});index.add({'id':14,'href':'/interview-me/docs/algs/dp/','title':"动态规划",'content':"动态规划 "});index.add({'id':15,'href':'/interview-me/docs/network/send/','title':"发包工具",'content':"发包工具 综合 常用发包工具有哪些？分别有什么特点，适用于什么场景？  PacketSender "});index.add({'id':16,'href':'/interview-me/docs/other/encode/','title':"字符编码",'content':"字符编码 Base 系列 参考：rfc4648\n有的字符在一些环境中是不能显示或使用的， 比如 \u0026amp;, = 等字符在 URL 被保留为特殊作用的字符； 比如描述一张图片，而图片中的二进制码如果转成对应的字符的话，会有很多不可见字符和控制符（如换行、回车之类）， 这时就需要对进行编码。\nBase 系列的就是用来将字节编码为 ASCII 中的可见字符的。\nBase64 Base64 编码是使用 64 个可打印 ASCII 字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成 ASCII 字符串，另有 “=” 符号用作后缀用途。\nBase64 将输入字符串按字节切分，取得每个字节对应的二进制值（若不足 8 比特则高位补 0）， 然后将这些二进制数值串联起来，再按照 6 比特一组进行切分（因为 2^6=64），最后一组若不足 6 比特则末尾补 0。\n由于二进制数据是按照 8 比特一组进行传输，因此 Base64 按照 6 比特一组切分的二进制数据必须是 24 比特的倍数（6 和 8 的最小公倍数）， 就是 3 个字节。 若原字节序列数据长度不是 3 的倍数时且剩下 1 个输入数据，则在编码结果后加 2 个 =；若剩下 2 个输入数据，则在编码结果后加 1 个 =。\n数据量扩大了 1/3。\nBase32 Base16 编码会将字节切为 5 个一组，所以此编码后会用到 32 个字符， 数据量扩大了 3/5（文本一长，最后填充的 0 和 = 的数据量差不多就可忽略不计了）。\n需要凑够 8 个字符\n00000001 00000011 00000111 00001111 00011111 =\u0026gt; 00000 00100 00001 10000 01110 00011 11000 11111 00000001 00000011 00000111 00001111 00011111 11111111 =\u0026gt; 00000 00100 00001 10000 01110 00011 11000 11111 11111 11100 = = = = = = // 最后不足 5 字节的重组后先在右边充 0，编码完成后再右边充 = 为什么后面要补 = 由于数据的二进制传输是按照 8 比特一组进行（即一个字节）， 因此 Base32 按 5 比特切分的二进制数据必须是 40 比特的倍数（5 和 8 的最小公倍数），就是 5 字节。\n填充 “=” 符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要， 而且，在 URL 中使用时必须去掉 “=” 符号。\n优点 与 Base64 相比，Base32 具有许多优点：\n 适合不区分大小写的文件系统，更利于人类口语交流或记忆。 结果可以用作文件名，因为它不包含路径分隔符 “/” 等符号。 排除了视觉上容易混淆的字符，因此可以准确的人工录入。 （例如，RFC4648 符号集忽略了数字 “1”、“8” 和 “0”，因为它们可能与字母 “I”，“B” 和 “O” 混淆）。 排除填充符号 “=” 的结果可以包含在 URL 中，而不编码任何字符。  Base32 也比 Base16 有优势：\n Base32 比 Base16 占用的空间更小。（1000 比特数据 Base32 需要 200 个字符，而 Base16 则为 250 个字符）  缺点 Base32 比 Base64 多占用大约 20％ 的空间 —— (8/5 - (8/6)) / (8/6)。\n因为 Base32 使用 8 个 ASCII 字符去编码原数据中的 5 个字节数据， 而 Base64 是使用 4 个 ASCII 字符去编码原数据中的 3 个字节数据。\n Base16 Base16 编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用， 因为它并不包含任何控制字符，以及 Base64 和 Base32 中的 = 符号。\nBase16 编码会将字节切为 4 个一组，所以此编码后会用到 16 个字符，数据会扩大 2 倍\n "});index.add({'id':17,'href':'/interview-me/docs/network/capture/','title':"抓包",'content':"抓包 综合 常用抓包工具有哪些？分别有什么特点，适用于什么场景？  tcpdump wireshark "});index.add({'id':18,'href':'/interview-me/docs/algs/sort/','title':"排序算法",'content':"排序算法 "});index.add({'id':19,'href':'/interview-me/docs/pl/go/type/','title':"数据类型",'content':"数据类型 "});index.add({'id':20,'href':'/interview-me/docs/algs/search/','title':"查询算法",'content':"查询算法 "});index.add({'id':21,'href':'/interview-me/docs/other/compile/','title':"编译",'content':"编译 "});index.add({'id':22,'href':'/interview-me/docs/se/design-pattern/principle/','title':"设计原则",'content':"设计原则 "});index.add({'id':23,'href':'/interview-me/docs/se/design-pattern/','title':"设计模式",'content':"设计模式 "});index.add({'id':24,'href':'/interview-me/docs/os/process/','title':"进程/线程/携程",'content':"进程/线程/携程 进程 一个进程包含哪些信息？  进程切换时，操作系统做了哪些事情？  进程切换时，需要保存哪些信息，保存在哪里？  线程 线程比进程轻量，体现在哪里？  什么时候使用线程，什么时候使用进程？  携程 协程是什么，怎么实现的？  既然协程那么好，那什么时候用进程和线程？ "});index.add({'id':25,'href':'/interview-me/docs/algs/link/','title':"链表",'content':"链表 "});index.add({'id':26,'href':'/interview-me/docs/pl/cpp/','title':"C++",'content':"C++ "});index.add({'id':27,'href':'/interview-me/docs/security/web/csrf/','title':"CSRF",'content':"CSRF  参考  前端安全系列（二）：如何防止 CSRF 攻击？  "});index.add({'id':28,'href':'/interview-me/docs/pl/go/keyword/','title':"关键字",'content':"关键字 "});index.add({'id':29,'href':'/interview-me/docs/se/architecture/','title':"架构设计",'content':"架构设计 教程 系统设计入门  "});index.add({'id':30,'href':'/interview-me/docs/se/architecture/principle/','title':"架构设计原则",'content':"架构设计原则 CAP (Consistency, Availability, Partition tolerance) 如何理解 CAP，你在做系统设计时是如何取舍的？  ACID (Atomicity, Consistency, Isolation, Durability)  BASE (Basically Available, Soft state, Eventual consistency) "});index.add({'id':31,'href':'/interview-me/docs/se/','title':"软件工程",'content':""});index.add({'id':32,'href':'/interview-me/docs/se/architecture/high-availability/','title':"高可用",'content':"高可用 "});index.add({'id':33,'href':'/interview-me/docs/se/architecture/high-concurrency/','title':"高并发",'content':"高并发 "});index.add({'id':34,'href':'/interview-me/docs/se/architecture/high-performance/','title':"高性能",'content':"高性能 "});index.add({'id':35,'href':'/interview-me/docs/se/architecture/high-scalability/','title':"高扩展性",'content':"高扩展性 如何构建高扩展性网站 参考：\n 如何构建高扩展性网站？   A Word on Scalability  "});index.add({'id':36,'href':'/interview-me/docs/pl/go/channel/','title':"Go Channel",'content':"Go Channel "});index.add({'id':37,'href':'/interview-me/docs/backend/','title':"后台",'content':""});index.add({'id':38,'href':'/interview-me/docs/backend/general/hot-restart/','title':"程序热重启",'content':"程序热重启 你使用的编程语言，是如何实现热重启的？  服务端启动时多开启一个协程用来监听关闭信号 当协程接收到关闭信号时，将拒绝接收新的连接，并处理好当前所有连接后断开 启动一个新的服务端进程来接管新的连接 关闭当前进程  Go Go 程序优雅关闭与重启 参考：\n gracehttp: 优雅重启 Go 程序（热启动 - Zero Downtime）  Java Python  "});index.add({'id':39,'href':'/interview-me/docs/backend/general/','title':"综合",'content':"综合 "});index.add({'id':40,'href':'/interview-me/docs/backend/general/hot-load/','title':"配置热加载",'content':"配置热加载 "});index.add({'id':41,'href':'/interview-me/docs/se/pm/','title':"项目管理",'content':"项目管理 "});index.add({'id':42,'href':'/interview-me/docs/pl/go/','title':"Go",'content':"Go "});index.add({'id':43,'href':'/interview-me/docs/pl/go/goroutine/','title':"Goroutine",'content':"Goroutine Goroutine 为什么高效？  Goroutine 如何调度？ 每个线程会都占用 1MB 以上的内存空间，在对线程进行切换时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁对应的资源， 每一次线程上下文的切换都需要消耗约为 1us， 但是 Go 调度器对 Goroutine 的上下文切换约为 0.2us，减少了 80% 的额外开销。\nGo 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销， 同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。\n参考：\n Go 语言调度器与 Goroutine 实现原理 [译] Go 调度器: M, P 和 G 也谈 goroutine 调度器  "});index.add({'id':44,'href':'/interview-me/docs/frontend/','title':"前端",'content':""});index.add({'id':45,'href':'/interview-me/docs/pl/go/pm/','title':"Go 包管理",'content':"Go 包管理 Go 包管理的进化过程是什么样的？  Go 1.4 及之前  所有的依赖包都是存放在 GOPATH 下，没有版本控制   Go 1.5 至 Go 1.10  每个项目的根目录下可以有一个 vendor 目录，里面存放了该项目的依赖的包   Go 1.11 至 Go 1.12  默认使用的还是 GOPATH 的管理方式 运行 export GO111MODULE=on，使用 Go Modules   Go 1.13 及之后  默认使用 Go Modules     你用过哪些 Go 包管理工具，说说它们的优缺点？   golang/dep   Masterminds/glide   kardianos/govendor    Go Mod 相对之前的版本管理有哪些优点？  可以指定版本   Go Mod 如何找到引用的包？ 一般情况：\n查看 $GOPATH/pkg/mod/\n设置 go mod vendor，使用 go build -mod=vendor 来构建项目时：\n 参考  Go 包管理  "});index.add({'id':46,'href':'/interview-me/docs/pl/java/','title':"Java",'content':"Java "});index.add({'id':47,'href':'/interview-me/docs/devops/','title':"运维",'content':""});index.add({'id':48,'href':'/interview-me/docs/pl/go/version/','title':"Go 版本",'content':"Go 版本 "});index.add({'id':49,'href':'/interview-me/docs/test/','title':"测试",'content':""});index.add({'id':50,'href':'/interview-me/docs/pl/go/std/','title':"Go 标准库",'content':"Go 标准库 "});index.add({'id':51,'href':'/interview-me/docs/security/','title':"安全",'content':""});index.add({'id':52,'href':'/interview-me/docs/pl/php/','title':"PHP",'content':"PHP "});index.add({'id':53,'href':'/interview-me/docs/pl/go/test/','title':"测试",'content':"测试 "});index.add({'id':54,'href':'/interview-me/docs/pl/python/','title':"Python",'content':"Python "});index.add({'id':55,'href':'/interview-me/docs/other/','title':"其他",'content':"其他 "});index.add({'id':56,'href':'/interview-me/docs/pl/go/performance/','title':"性能",'content':"性能 "});index.add({'id':57,'href':'/interview-me/docs/pl/rust/','title':"Rust",'content':"Rust "});index.add({'id':58,'href':'/interview-me/docs/','title':"Docs",'content':""});})();